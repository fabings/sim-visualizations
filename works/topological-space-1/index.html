<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Euler Topology: ℝ ⟷ ℂ Continuum</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }
        
        /* ハンバーガーボタン共通スタイル */
        .menu-toggle {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 5px;
            z-index: 1001;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }
        
        .menu-toggle:hover {
            box-shadow: 0 0 20px;
            transform: scale(1.05);
        }
        
        .menu-toggle:active {
            transform: scale(0.95);
        }
        
        .menu-toggle span {
            width: 28px;
            height: 3px;
            background: currentColor;
            border-radius: 2px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* アクティブ時: ×マークに変形 */
        .menu-toggle.active span:nth-child(1) {
            transform: translateY(8px) rotate(45deg);
        }
        
        .menu-toggle.active span:nth-child(2) {
            opacity: 0;
            transform: scaleX(0);
        }
        
        .menu-toggle.active span:nth-child(3) {
            transform: translateY(-8px) rotate(-45deg);
        }
        
        /* コントロールパネル用ハンバーガー（左上） */
        #controls-toggle {
            top: 20px;
            left: 20px;
            border-color: #00ffff;
            color: #00ffff;
            z-index: 1002;
        }
        
        #controls-toggle:hover {
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }
        
        /* 位相的構造用ハンバーガー（右上） */
        #topology-toggle {
            top: 20px;
            right: 20px;
            border-color: #ff00ff;
            color: #ff00ff;
            z-index: 1002;
        }
        
        #topology-toggle:hover {
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
        }
        
        /* コントロールパネル（左上から展開） */
        #controls {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            border: 2px solid #00ffff;
            border-radius: 8px;
            max-width: 380px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
            z-index: 1000;
            transform-origin: top left;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }
        
        #controls.hidden {
            transform: translateY(-20px) scale(0.9);
            opacity: 0;
            pointer-events: none;
            visibility: hidden;
        }
        h2 {
            color: #00ffff;
            font-size: 16px;
            margin-bottom: 15px;
            text-align: center;
            letter-spacing: 2px;
        }
        .section {
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 50, 50, 0.3);
            border-left: 3px solid #00ff88;
        }
        .section-title {
            color: #00ff88;
            font-size: 12px;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .control-group {
            margin: 12px 0;
        }
        label {
            display: block;
            color: #aaa;
            font-size: 11px;
            margin-bottom: 5px;
        }
        .math {
            color: #ffaa00;
            font-style: italic;
        }
        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #333;
            outline: none;
            border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00ffff;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ffff;
            cursor: pointer;
            border-radius: 50%;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        /* タッチデバイスでのスライダー操作性向上 */
        @media (hover: none) {
            input[type="range"] {
                height: 8px;
            }
            
            input[type="range"]::-webkit-slider-thumb {
                width: 28px;
                height: 28px;
            }
            
            input[type="range"]::-moz-range-thumb {
                width: 28px;
                height: 28px;
            }
        }
        .value-display {
            color: #00ffff;
            font-weight: bold;
            font-size: 13px;
        }
        .info {
            font-size: 9px;
            color: #666;
            margin-top: 5px;
            line-height: 1.4;
            font-style: italic;
        }
        button {
            width: 100%;
            padding: 12px;
            margin-top: 15px;
            background: linear-gradient(135deg, #00ffff, #00ff88);
            border: none;
            border-radius: 4px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            font-size: 12px;
            letter-spacing: 1px;
            min-height: 44px;
            transition: all 0.2s ease;
        }
        
        button:hover {
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
        }
        
        button:active {
            transform: scale(0.98);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
        }
        
        @media (hover: none) {
            button:hover {
                box-shadow: none;
            }
        }
        /* 位相的構造情報パネル（右上から展開） */
        #topology-info {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border: 2px solid #ff00ff;
            border-radius: 8px;
            max-width: 380px;
            color: #ff00ff;
            font-size: 10px;
            line-height: 1.6;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.4);
            z-index: 1000;
            transform-origin: top right;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }
        
        #topology-info.hidden {
            transform: translateY(-20px) scale(0.9);
            opacity: 0;
            pointer-events: none;
            visibility: hidden;
        }
        
        /* スクロールバーのスタイル */
        #controls::-webkit-scrollbar {
            width: 8px;
        }
        
        #controls::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
        }
        
        #controls::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 255, 0.5);
            border-radius: 4px;
        }
        
        #controls::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 255, 0.8);
        }
        
        /* レスポンシブ対応 */
        @media (max-width: 768px) {
            .menu-toggle {
                width: 45px;
                height: 45px;
            }
            
            #controls {
                max-width: calc(100vw - 100px);
                max-height: calc(100vh - 120px);
            }
            
            #topology-info {
                max-width: calc(100vw - 100px);
            }
        }
        
        @media (max-width: 480px) {
            .menu-toggle {
                width: 40px;
                height: 40px;
            }
            
            .menu-toggle span {
                width: 24px;
            }
            
            #controls-toggle {
                top: 15px;
                left: 15px;
            }
            
            #topology-toggle {
                top: 15px;
                right: 15px;
            }
            
            #controls {
                top: 65px;
                left: 15px;
                right: auto;
                max-width: calc(100vw - 30px);
                max-height: calc(100vh - 80px);
            }
            
            #topology-info {
                top: 65px;
                right: 15px;
                left: auto;
                max-width: calc(100vw - 30px);
                max-height: 50vh;
            }
            
            #controls.hidden,
            #topology-info.hidden {
                transform: translateY(-20px) scale(0.9);
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <!-- ハンバーガーメニューボタン：コントロールパネル -->
    <div id="controls-toggle" class="menu-toggle">
        <span></span>
        <span></span>
        <span></span>
    </div>
    
    <!-- ハンバーガーメニューボタン：位相的構造 -->
    <div id="topology-toggle" class="menu-toggle">
        <span></span>
        <span></span>
        <span></span>
    </div>
    
    <!-- コントロールパネル -->
    <div id="controls" class="hidden">
        <h2>位相的パラメータ空間</h2>
        
        <div class="section">
            <div class="section-title">位相遷移パラメータ</div>
            
            <div class="control-group">
                <label>
                    <span class="math">t</span> ∈ [0,1]: 実数性 ⟷ 複素性
                    <span class="value-display" id="t-value">0.50</span>
                </label>
                <input type="range" id="t-slider" min="0" max="1" step="0.001" value="0.5">
                <div class="info">t=0: ℝ上の三角力学系 | t=1: ℂ上の指数力学系</div>
            </div>

            <div class="control-group">
                <label>
                    遷移鋭敏度 <span class="math">k</span>
                    <span class="value-display" id="k-value">20.0</span>
                </label>
                <input type="range" id="k-slider" min="0.5" max="20" step="0.1" value="20">
                <div class="info">σ(t) = ½(1 + tanh(k(t-½))) による滑らかな遷移</div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">力学系パラメータ</div>
            
            <div class="control-group">
                <label>
                    複素パラメータ <span class="math">c</span> (実部)
                    <span class="value-display" id="c-real-value">2.00</span>
                </label>
                <input type="range" id="c-real" min="-2" max="2" step="0.01" value="2.0">
            </div>

            <div class="control-group">
                <label>
                    複素パラメータ <span class="math">c</span> (虚部)
                    <span class="value-display" id="c-imag-value">-2.00</span>
                </label>
                <input type="range" id="c-imag" min="-2" max="2" step="0.01" value="-2.0">
            </div>

            <div class="control-group">
                <label>
                    実数振幅 <span class="math">r</span>
                    <span class="value-display" id="r-value">4.00</span>
                </label>
                <input type="range" id="r-slider" min="0.5" max="4" step="0.01" value="4.0">
                <div class="info">f_ℝ(x) = r·sin(πx)</div>
            </div>

            <div class="control-group">
                <label>
                    スケール <span class="math">λ</span>
                    <span class="value-display" id="lambda-value">1.10</span>
                </label>
                <input type="range" id="lambda-slider" min="0.5" max="5" step="0.01" value="1.10">
                <div class="info">f_ℂ(z) = c·exp(z/λ)</div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">可視化設定</div>
            
            <div class="control-group">
                <label>
                    反復回数
                    <span class="value-display" id="iter-value">50</span>
                </label>
                <input type="range" id="iterations" min="50" max="500" step="10" value="50">
            </div>

            <div class="control-group">
                <label>
                    粒子密度
                    <span class="value-display" id="particles-value">25000</span>
                </label>
                <input type="range" id="particle-count" min="5000" max="50000" step="1000" value="25000">
            </div>

            <div class="control-group">
                <label>
                    時間速度
                    <span class="value-display" id="speed-value">0.020</span>
                </label>
                <input type="range" id="speed-slider" min="0" max="0.02" step="0.001" value="0.020">
            </div>
        </div>

        <button id="animate-btn">自動遷移アニメーション</button>
    </div>
    
    <!-- 位相的構造情報パネル -->
    <div id="topology-info" class="hidden">
        <strong>位相的構造:</strong><br>
        F_t(z) = e^(iπt) · [(1-σ(t))·sin(πz) + σ(t)·c·exp(z/λ)]<br><br>
        <strong>オイラー接続:</strong> e^(iθ) = cos(θ) + i·sin(θ)<br>
        <strong>商空間:</strong> ℝ/2πℤ ≅ S¹ ⊂ ℂ<br>
        <strong>解析接続:</strong> 実軸制限 → 複素平面全体
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', { 
            antialias: true,
            alpha: false,
            premultipliedAlpha: false
        });
        
        if (!gl) {
            alert('WebGL2 not supported');
        }

        /**
         * キャンバスのリサイズとアスペクト比の計算
         * 
         * WebGLの正規化デバイス座標（NDC）は常に正方形 [-1,1]² だが、
         * 実際の画面は任意のアスペクト比を持つ長方形である。
         * 
         * 問題:
         * - NDCの正方形が、長方形の画面に引き伸ばされる
         * - 数学的な円が楕円に歪む
         * - 対称性が破壊される
         * 
         * 解決策:
         * - devicePixelRatio を考慮した高解像度レンダリング
         * - アスペクト比 = width / height を計算
         * - シェーダーで座標補正を行う
         * 
         * 数学的効果:
         * - 等長変換（isometry）ではないが、形状保存変換
         * - 円環 S¹ の幾何学的性質を保存
         */
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            
            // 物理ピクセルサイズに設定（高DPI対応）
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            
            // ビューポートも同様に設定
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        /**
         * 現在のアスペクト比を取得
         * @returns {number} aspect = width / height
         */
        function getAspectRatio() {
            return canvas.width / canvas.height;
        }
        
        /**
         * デバイスピクセル比を取得
         * @returns {number} デバイスピクセル比（Retina等では2.0以上）
         */
        function getPixelRatio() {
            return window.devicePixelRatio || 1;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Vertex shader with topological dynamics
        const vertexShaderSource = `#version 300 es
            precision highp float;
            
            in vec2 a_initialPos;
            
            uniform float u_t;
            uniform float u_k;
            uniform vec2 u_c;
            uniform float u_r;
            uniform float u_lambda;
            uniform int u_iterations;
            uniform float u_time;
            uniform float u_aspect;
            uniform float u_pixelRatio;
            
            out vec4 v_color;
            out float v_speed;
            
            const float PI = 3.14159265359;
            const float TAU = 6.28318530718;
            
            // 滑らかな遷移関数 σ(t) = ½(1 + tanh(k(t-½)))
            float sigma(float t, float k) {
                float x = k * (t - 0.5);
                return 0.5 * (1.0 + tanh(x));
            }
            
            // 複素数演算
            vec2 complexMul(vec2 a, vec2 b) {
                return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
            }
            
            vec2 complexExp(vec2 z) {
                float r = exp(z.x);
                return vec2(r * cos(z.y), r * sin(z.y));
            }
            
            // 実数力学系: f_ℝ(x) = r·sin(πx)
            float realDynamics(float x, float r) {
                return r * sin(PI * x);
            }
            
            // 複素力学系: f_ℂ(z) = c·exp(z/λ)
            vec2 complexDynamics(vec2 z, vec2 c, float lambda) {
                vec2 scaled = z / lambda;
                vec2 expZ = complexExp(scaled);
                return complexMul(c, expZ);
            }
            
            // オイラー位相回転: e^(iπt)
            vec2 eulerRotation(float t) {
                return vec2(cos(PI * t), sin(PI * t));
            }
            
            // 統一力学系 F_t(z)
            vec2 unifiedDynamics(vec2 z, float t, float k, vec2 c, float r, float lambda) {
                float s = sigma(t, k);
                
                // 実数成分（実軸への射影で計算）
                float realPart = realDynamics(z.x, r);
                vec2 realContribution = vec2(realPart, z.y * 0.98);
                
                // 複素成分
                vec2 complexContribution = complexDynamics(z, c, lambda);
                
                // 補間
                vec2 interpolated = mix(realContribution, complexContribution, s);
                
                // オイラー位相回転を適用
                vec2 rotation = eulerRotation(t);
                return complexMul(interpolated, rotation);
            }
            
            // 軌道の色相計算
            vec3 orbitColor(vec2 z, int escapeIter, int maxIter, float speed) {
                float hue = float(escapeIter) / float(maxIter);
                // 時間による色相シフト（mod演算により常に[0,1]の範囲を保証）
                // u_timeはJavaScript側で周期的にリセットされるため、数値的に安定
                hue = mod(hue + u_time * 0.1, 1.0);
                
                // 速度に基づく彩度
                float saturation = clamp(speed * 2.0, 0.3, 1.0);
                
                // 位置に基づく明度（中心部を強調、外側を減衰）
                // 
                // 改善点: 外側の粒子の明度を低減
                // distanceFactor: 中心部で1.0、外側で減衰
                float dist = length(z);
                float distanceFactor = 1.0 / (1.0 + dist * 0.3);
                
                // 時間による明度の振動（u_timeは周期的にリセットされる）
                // sin関数の周期性により、リセット後も視覚的に連続
                float baseBrightness = 0.5 + 0.5 * sin(dist * 2.0 + u_time);
                float brightness = baseBrightness * distanceFactor;
                
                // HSV to RGB
                float c = brightness * saturation;
                float x = c * (1.0 - abs(mod(hue * 6.0, 2.0) - 1.0));
                float m = brightness - c;
                
                vec3 rgb;
                if (hue < 1.0/6.0) rgb = vec3(c, x, 0);
                else if (hue < 2.0/6.0) rgb = vec3(x, c, 0);
                else if (hue < 3.0/6.0) rgb = vec3(0, c, x);
                else if (hue < 4.0/6.0) rgb = vec3(0, x, c);
                else if (hue < 5.0/6.0) rgb = vec3(x, 0, c);
                else rgb = vec3(c, 0, x);
                
                return rgb + m;
            }
            
            void main() {
                vec2 z = a_initialPos;
                vec2 prevZ = z;
                int escapeIter = u_iterations;
                float totalSpeed = 0.0;
                
                // 軌道の反復計算
                for (int i = 0; i < 500; i++) {
                    if (i >= u_iterations) break;
                    
                    prevZ = z;
                    z = unifiedDynamics(z, u_t, u_k, u_c, u_r, u_lambda);
                    
                    // 速度計算
                    float speed = length(z - prevZ);
                    totalSpeed += speed;
                    
                    // 発散判定
                    if (length(z) > 10.0) {
                        escapeIter = i;
                        break;
                    }
                }
                
                float avgSpeed = totalSpeed / float(u_iterations);
                v_speed = avgSpeed;
                
                // 位置を画面座標に変換（適応的スケーリング + アスペクト比補正）
                // 
                // ステップ1: 基本的な適応的スケーリング
                // S(z) = 0.2 / (1 + 0.1|z|)
                // これにより、遠方の粒子を圧縮して画面内に収める
                float scale = 0.2 / (1.0 + length(z) * 0.1);
                
                // ステップ2: アスペクト比に応じた視野調整
                // 
                // 問題: 縦長画面では縦方向の視野が広がり、発散領域が多く見える
                // 解決: アスペクト比に応じてスケールを調整し、視野を最適化
                // 
                // 数学的設計:
                // - aspect > 1 (横長): x方向の視野が広い → ズーム不要
                // - aspect < 1 (縦長): y方向の視野が広い → ズームインして中心部を強調
                // 
                // ズーム係数:
                // zoom = max(1.0, 1.0/aspect) の平方根を使用
                // aspect = 0.5 → zoom = √2 ≈ 1.41 (約1.4倍ズームイン)
                // aspect = 1.0 → zoom = 1.0 (ズームなし)
                // aspect = 2.0 → zoom = 1.0 (ズームなし)
                float zoom = sqrt(max(1.0, 1.0 / u_aspect));
                scale *= zoom;
                
                vec2 pos = z * scale;
                
                // ステップ3: アスペクト比補正（円の歪み防止）
                // NDC上で事前に補正することで、画面上で円が円として表示される
                if (u_aspect > 1.0) {
                    pos.x /= u_aspect;
                } else {
                    pos.y *= u_aspect;
                }
                
                gl_Position = vec4(pos, 0.0, 1.0);
                
                // 点のサイズ（最適化：視認性とシャープネスのバランス）
                // 
                // 問題の分析:
                // - サイズが大きい → ぼやけやすい（ガウシアンが広がる）
                // - サイズが小さい → 見えにくい
                // 
                // 解決策:
                // 1. baseSizeを小さめに（1.2 + v×2.5）
                // 2. ガウシアン係数を大きく（k=24）
                // 3. ズーム補正は適度に（√zoom × 0.9）
                // 
                // 数学的設計:
                // baseSize = 1.2 + avgSpeed × 2.5
                // - 静止点（v≈0）: 1.2 px
                // - 中速点（v≈0.5）: 2.45 px
                // - 高速点（v≈1）: 3.7 px
                // 
                // サイズ調整係数:
                // adjustment = √zoom × 0.9
                // 
                // 効果（スマホ、zoom=1.47）:
                // adjustment = 1.21 × 0.9 = 1.09
                // gl_PointSize = 1.2 × 3 × 1.09 = 3.92 px
                // 論理サイズ = 1.31 px
                // 
                // 効果（PC、zoom=1.0）:
                // adjustment = 1.0 × 0.9 = 0.9
                // gl_PointSize = 1.2 × 2 × 0.9 = 2.16 px
                // 論理サイズ = 1.08 px
                // 
                // 結果: 小さくシャープだが十分視認可能
                float baseSize = 1.2 + avgSpeed * 2.5;
                float zoomSizeAdjustment = sqrt(zoom) * 0.9;
                gl_PointSize = baseSize * u_pixelRatio * zoomSizeAdjustment;
                
                // 色の計算
                vec3 color = orbitColor(z, escapeIter, u_iterations, avgSpeed);
                
                // アルファ値の計算（視野に応じた調整）
                // 
                // 基本: 中心部ほど不透明、外側ほど透明
                // alpha_base = 1.0 - 0.1|z|
                // 
                // ズーム時の調整:
                // - 外側の発散領域をより透明に
                // - ただし、中心部の粒子は十分な不透明度を維持
                // 
                // 数学的設計:
                // 1. 距離に基づく基本アルファ
                // 2. ズーム係数による外側の追加透明化
                // 3. 下限を0.3に設定（0.2から引き上げ）
                float distanceFromCenter = length(z);
                float baseAlpha = 1.0 - distanceFromCenter * 0.1;
                
                // ズーム係数に応じた透明化（やや緩和）
                // 
                // 旧: mix(1.0, 0.7, ...) → 最大30%透明化
                // 新: mix(1.0, 0.8, ...) → 最大20%透明化
                // 
                // 理由: 点サイズ調整により十分視認可能なため、
                //       過度な透明化は不要
                float zoomFactor = sqrt(max(1.0, 1.0 / u_aspect));
                float alphaAdjustment = mix(1.0, 0.8, (zoomFactor - 1.0) / 0.5);
                
                // clamp の下限を 0.3 に引き上げ
                // 外側の粒子も最低限の視認性を保証
                float alpha = clamp(baseAlpha * alphaAdjustment, 0.3, 0.9);
                
                v_color = vec4(color, alpha);
            }
        `;

        const fragmentShaderSource = `#version 300 es
            precision highp float;
            
            in vec4 v_color;
            in float v_speed;
            out vec4 fragColor;
            
            void main() {
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                
                if (dist > 0.5) discard;
                
                // ガウシアンフォールオフ（極めてシャープな点の描画）
                // 
                // 改善: 減衰係数をさらに強化し、極めて鮮明な点を実現
                // 
                // 数学的解析:
                // I(d) = exp(-k·d²)
                // 
                // k値の進化:
                // k = 8.0:  FWHM ≈ 0.59, ぼやけあり
                // k = 12.0: FWHM ≈ 0.48, シャープ
                // k = 16.0: FWHM ≈ 0.42, 非常にシャープ
                // k = 24.0: FWHM ≈ 0.34, 極めてシャープ ← 採用
                // 
                // k = 24.0 の輝度分布:
                //   d = 0.0:  I = 1.000 (中心、最大輝度)
                //   d = 0.1:  I = 0.787 (中心寄りでも減衰開始)
                //   d = 0.15: I = 0.549 (半値に近い)
                //   d = 0.2:  I = 0.278 (急激に減衰)
                //   d = 0.25: I = 0.105 (非常に暗い)
                //   d = 0.3:  I = 0.027
                //   d = 0.4:  I = 0.0008 (ほぼ完全に0)
                //   d = 0.5:  I = 0.00001 (完全に0)
                // 
                // 効果:
                // - 中心部（d < 0.15）のみ明るい
                // - 外縁（d > 0.2）は非常に暗い
                // - 点が極めてクリスプで鮮明
                // - ぼやけが最小限
                // - ピクセルパーフェクトに近い表現
                float intensity = exp(-dist * dist * 24.0);
                
                // 速度に基づくグロー（抑制的な設定）
                // 
                // 改善: グロー効果を控えめに設定
                // 
                // speedBoost = 1.0 + v_speed × k_boost
                // 
                // k_boost の履歴:
                // 2.0 → 1.5 → 1.2 → 1.0 (最新)
                // 
                // 効果（v_speed = 0.8 の場合）:
                // k_boost = 2.0: boost = 2.6 (260%、強すぎ)
                // k_boost = 1.5: boost = 2.2 (220%)
                // k_boost = 1.2: boost = 1.96 (196%)
                // k_boost = 1.0: boost = 1.8 (180%、適度)
                // 
                // より自然で落ち着いた発光
                // 速度の視覚的表現は維持しつつ、過剰な輝度を防止
                float speedBoost = 1.0 + v_speed * 1.0;
                
                // グロー強度の計算
                vec3 glow = v_color.rgb * intensity * speedBoost;
                
                // 最終的なアルファ値
                // 頂点シェーダーからのアルファ値にガウシアン強度を掛ける
                float finalAlpha = v_color.a * intensity;
                
                fragColor = vec4(glow, finalAlpha);
            }
        `;

        // Shader compilation
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(program));
        }

        // Get locations
        const initialPosLoc = gl.getAttribLocation(program, 'a_initialPos');
        const tLoc = gl.getUniformLocation(program, 'u_t');
        const kLoc = gl.getUniformLocation(program, 'u_k');
        const cLoc = gl.getUniformLocation(program, 'u_c');
        const rLoc = gl.getUniformLocation(program, 'u_r');
        const lambdaLoc = gl.getUniformLocation(program, 'u_lambda');
        const iterationsLoc = gl.getUniformLocation(program, 'u_iterations');
        const timeLoc = gl.getUniformLocation(program, 'u_time');
        const aspectLoc = gl.getUniformLocation(program, 'u_aspect');
        const pixelRatioLoc = gl.getUniformLocation(program, 'u_pixelRatio');

        // 粒子システムの初期化
        let particleCount = 25000; // 初期粒子密度
        let particles;
        let initialPosBuffer;

        /**
         * 粒子の初期位置を生成し、バッファを更新
         * @param {number} count - 粒子数
         */
        function initParticles(count) {
            particleCount = count;
            particles = new Float32Array(count * 2);
            
            // 初期位置を円形に配置（位相的に意味のある配置）
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const radius = Math.sqrt(i / count) * 2.5;
                particles[i * 2] = Math.cos(angle) * radius;
                particles[i * 2 + 1] = Math.sin(angle) * radius;
            }

            if (initialPosBuffer) gl.deleteBuffer(initialPosBuffer);
            
            initialPosBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, initialPosBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, particles, gl.STATIC_DRAW);
        }

        initParticles(particleCount);
        
        /**
         * パフォーマンスモニタリング（開発・デバッグ用）
         * 
         * 長時間実行時の安定性を監視するための変数
         * 本番環境では削除可能だが、問題の早期発見に有用
         */
        let frameCount = 0;
        let lastFPSUpdate = performance.now();
        let currentFPS = 60;

        /**
         * 位相空間パラメータの初期値設定
         * 
         * t: 位相遷移パラメータ [0,1] (0=実数空間, 1=複素空間)
         * k: 遷移の鋭敏度（大きいほど急峻な遷移）
         * cReal, cImag: 複素パラメータ c の実部・虚部
         * r: 実数力学系の振幅パラメータ
         * lambda: 複素力学系のスケールパラメータ
         * iterations: 軌道計算の反復回数
         * speed: 自動アニメーションの速度
         * animating: 自動アニメーションの有効/無効
         */
        let params = {
            t: 0.5,           // 位相遷移パラメータ（中間状態）
            k: 20.0,          // 遷移鋭敏度
            cReal: 2.0,       // 複素パラメータ c の実部
            cImag: -2.0,      // 複素パラメータ c の虚部
            r: 4.0,           // 実数振幅
            lambda: 1.10,     // スケール λ
            iterations: 50,   // 反復回数
            speed: 0.020,     // 時間速度
            animating: true  // アニメーション状態
        };

        /**
         * 時間管理変数
         * 
         * TIME_DELTA: 1フレームあたりの時間増分（固定値）
         * time: グローバルな経過時間（色相計算などに使用）
         * animationPhase: アニメーション専用の位相角度
         * 
         * 設計意図:
         * - TIME_DELTAは時間の基本単位を定義
         * - timeは全体の経過時間を表し、視覚効果に使用
         * - animationPhaseはアニメーションの位相を独立管理し、
         *   speedパラメータ変更時も連続性を保つ
         * - 位相増分 = speed × TIME_DELTA により、旧実装と同じ速度スケール
         * 
         * 長時間実行の安定性:
         * - time と animationPhase は周期的にリセット（mod演算）
         * - これにより浮動小数点精度の劣化を防止
         * - 無限に増加する変数による数値的不安定性を回避
         */
        const TIME_DELTA = 0.01;  // 1フレームあたりの時間増分
        const TIME_CYCLE = 100.0;  // 時間のリセット周期（色相計算用）
        const TAU = Math.PI * 2;   // 2π（位相の周期）
        
        let time = 0;
        let animationPhase = 0;  // アニメーション専用の位相変数

        // UI Controls
        const controls = {
            t: document.getElementById('t-slider'),
            k: document.getElementById('k-slider'),
            cReal: document.getElementById('c-real'),
            cImag: document.getElementById('c-imag'),
            r: document.getElementById('r-slider'),
            lambda: document.getElementById('lambda-slider'),
            iterations: document.getElementById('iterations'),
            particles: document.getElementById('particle-count'),
            speed: document.getElementById('speed-slider'),
            animateBtn: document.getElementById('animate-btn')
        };

        /**
         * ハンバーガーメニューの制御
         */
        const controlsPanel = document.getElementById('controls');
        const controlsToggle = document.getElementById('controls-toggle');
        const topologyPanel = document.getElementById('topology-info');
        const topologyToggle = document.getElementById('topology-toggle');

        /**
         * 初期状態の設定
         * HTMLで既にhiddenクラスが設定されているため、
         * ボタンの状態のみ確認する
         */
        function initMenuState() {
            // ボタンは通常のハンバーガーメニュー表示（activeなし）
            // HTMLで既にパネルはhiddenクラス付きで定義されている
            controlsToggle.classList.remove('active');
            topologyToggle.classList.remove('active');
        }

        /**
         * コントロールパネルのトグル
         * 
         * ロジック:
         * - パネルが閉じている（hidden）→ 開く → ボタンを×マーク（active）
         * - パネルが開いている → 閉じる → ボタンをハンバーガー（active解除）
         */
        controlsToggle.addEventListener('click', () => {
            const isHidden = controlsPanel.classList.contains('hidden');
            
            if (isHidden) {
                // 閉じている → 開く
                controlsPanel.classList.remove('hidden');
                controlsToggle.classList.add('active');
            } else {
                // 開いている → 閉じる
                controlsPanel.classList.add('hidden');
                controlsToggle.classList.remove('active');
            }
        });

        /**
         * 位相的構造パネルのトグル
         */
        topologyToggle.addEventListener('click', () => {
            const isHidden = topologyPanel.classList.contains('hidden');
            
            if (isHidden) {
                // 閉じている → 開く
                topologyPanel.classList.remove('hidden');
                topologyToggle.classList.add('active');
            } else {
                // 開いている → 閉じる
                topologyPanel.classList.add('hidden');
                topologyToggle.classList.remove('active');
            }
        });

        /**
         * ウィンドウリサイズ時の対応
         * デスクトップに戻した時も閉じた状態を維持
         */
        window.addEventListener('resize', () => {
            // リサイズ時は現在の状態を維持
            // 特別な処理は不要
        });

        // 初期化（両方閉じた状態で開始）
        initMenuState();

        controls.t.addEventListener('input', (e) => {
            params.t = parseFloat(e.target.value);
            document.getElementById('t-value').textContent = params.t.toFixed(3);
        });

        controls.k.addEventListener('input', (e) => {
            params.k = parseFloat(e.target.value);
            document.getElementById('k-value').textContent = params.k.toFixed(1);
        });

        controls.cReal.addEventListener('input', (e) => {
            params.cReal = parseFloat(e.target.value);
            document.getElementById('c-real-value').textContent = params.cReal.toFixed(2);
        });

        controls.cImag.addEventListener('input', (e) => {
            params.cImag = parseFloat(e.target.value);
            document.getElementById('c-imag-value').textContent = params.cImag.toFixed(2);
        });

        controls.r.addEventListener('input', (e) => {
            params.r = parseFloat(e.target.value);
            document.getElementById('r-value').textContent = params.r.toFixed(2);
        });

        controls.lambda.addEventListener('input', (e) => {
            params.lambda = parseFloat(e.target.value);
            document.getElementById('lambda-value').textContent = params.lambda.toFixed(2);
        });

        controls.iterations.addEventListener('input', (e) => {
            params.iterations = parseInt(e.target.value);
            document.getElementById('iter-value').textContent = params.iterations;
        });

        controls.particles.addEventListener('input', (e) => {
            const newCount = parseInt(e.target.value);
            document.getElementById('particles-value').textContent = newCount;
            initParticles(newCount);
        });

        controls.speed.addEventListener('input', (e) => {
            params.speed = parseFloat(e.target.value);
            document.getElementById('speed-value').textContent = params.speed.toFixed(3);
        });

        /**
         * アニメーション開始/停止ボタンのイベントハンドラ
         * 
         * アニメーション開始時の挙動:
         * - 現在のt値から逆算してanimationPhaseを初期化
         * - これにより、アニメーション開始時に位相が急変しない
         */
        controls.animateBtn.addEventListener('click', () => {
            params.animating = !params.animating;
            controls.animateBtn.textContent = params.animating ? '停止' : '自動遷移アニメーション';
            
            // アニメーション開始時: 現在のt値から位相を逆算
            if (params.animating) {
                // params.t = 0.5 + 0.5 * sin(phase) の逆算
                // sin(phase) = (params.t - 0.5) / 0.5 = 2 * params.t - 1
                const currentSinValue = 2 * params.t - 1;
                
                // arcsin は [-π/2, π/2] の範囲を返すため、
                // 現在の増減方向を考慮して位相を設定
                animationPhase = Math.asin(Math.max(-1, Math.min(1, currentSinValue)));
            }
        });

        /**
         * メインレンダリングループ
         * 
         * 時間管理の設計:
         * 1. time: TIME_DELTAずつ増加、周期的にリセット（色相などの視覚効果用）
         * 2. animationPhase: speed × TIME_DELTA で増分、2πでリセット（位相遷移用）
         * 
         * 位相増分の計算:
         * - Δφ = speed × TIME_DELTA
         * - これにより、旧実装（time × speed）と同じ速度スケールを維持
         * - 例: speed=0.020, TIME_DELTA=0.01 → Δφ=0.0002 rad/frame
         * 
         * speedパラメータの意味:
         * - 時間に対する速度係数（無次元）
         * - 値が大きいほど速くsin関数が振動
         * 
         * 長時間実行の安定性:
         * - time % TIME_CYCLE により周期的にリセット
         * - animationPhase % TAU により2π周期でリセット
         * - 浮動小数点精度の劣化を防止
         * - 数値的安定性を長期間保証
         * 
         * この分離により、speedを変更しても位相の連続性が保たれる
         */
        function render() {
            // 時間を増分し、周期的にリセット（精度維持のため）
            time += TIME_DELTA;
            if (time >= TIME_CYCLE) {
                time = time % TIME_CYCLE;
            }
            
            // 自動アニメーション
            if (params.animating) {
                // 位相を速度に応じて増分（連続的に変化）
                // TIME_DELTAを掛けることで、旧実装と同じ速度スケールを維持
                animationPhase += params.speed * TIME_DELTA;
                
                // 位相を2π周期でリセット（精度維持と数値安定性のため）
                // sin関数は周期2πなので、mathematicallyに等価
                if (animationPhase >= TAU) {
                    animationPhase = animationPhase % TAU;
                }
                // 負の方向にも対応（speedが負になることはないが、念のため）
                if (animationPhase < 0) {
                    animationPhase = animationPhase % TAU + TAU;
                }
                
                // 位相から位相遷移パラメータを計算
                // sin関数により [0, 1] の範囲で滑らかに振動
                params.t = 0.5 + 0.5 * Math.sin(animationPhase);
                
                // UI要素を更新
                controls.t.value = params.t;
                document.getElementById('t-value').textContent = params.t.toFixed(3);
            }
            
            // クリアとブレンディング設定
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            // ブレンディング設定（初回のみ設定済みだが、念のため毎フレーム設定）
            // 加算ブレンディング: 光の加算効果
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

            gl.useProgram(program);

            // Set uniforms
            gl.uniform1f(tLoc, params.t);
            gl.uniform1f(kLoc, params.k);
            gl.uniform2f(cLoc, params.cReal, params.cImag);
            gl.uniform1f(rLoc, params.r);
            gl.uniform1f(lambdaLoc, params.lambda);
            gl.uniform1i(iterationsLoc, params.iterations);
            gl.uniform1f(timeLoc, time);
            gl.uniform1f(aspectLoc, getAspectRatio());
            gl.uniform1f(pixelRatioLoc, getPixelRatio());

            // Bind attributes
            gl.bindBuffer(gl.ARRAY_BUFFER, initialPosBuffer);
            gl.enableVertexAttribArray(initialPosLoc);
            gl.vertexAttribPointer(initialPosLoc, 2, gl.FLOAT, false, 0, 0);

            // Draw
            gl.drawArrays(gl.POINTS, 0, particleCount);
            
            // パフォーマンスモニタリング
            // 
            // 長時間実行時の安定性確認
            // FPSが大きく低下した場合、コンソールに警告を出力
            frameCount++;
            const now = performance.now();
            const elapsed = now - lastFPSUpdate;
            
            if (elapsed >= 1000) {
                currentFPS = (frameCount * 1000) / elapsed;
                
                // FPSが30未満に低下した場合、警告
                if (currentFPS < 30) {
                    console.warn(`⚠️ パフォーマンス低下検出: ${currentFPS.toFixed(1)} FPS`);
                }
                
                frameCount = 0;
                lastFPSUpdate = now;
            }

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>
